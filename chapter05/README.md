## 1. 도전과제

- 모든 비즈니스 기능이 어떤 조건에 따라 액션을 유발하는 규칙을 정의할 수 있어야한다는 사실을 알게되었다.

## 2. 목표

- TDD로 새로운 설계 문제를 풀어나가는 방법을 배운다.
- 단위테스트 구현에 유용한 모킹(Mocking)기법을 전반적으로 배운다.
- 지역변수형식 추론, switch문 등 몇가지 최신 자바 기술을 살펴본다.
- 빌더패턴(Builder Pattern)과 인터페이스분리원칙(ISP)으로 사용자 친화적인 API개발 방법을 배운다.

## 3. 요구사항

- 프로그래머가 아닌 사람도 자신의 work flow에 비즈니스 로직을 추가하거나 바꿀수 있는 기능을 만든다.
- 비즈니스 규칙엔진은 간단한 맞춤 언어를 사용해, 한 개 이상의 비즈니스 규칙을 실행하는 소프트웨어로 다양한 컴포넌트를 동시지원한다.
    - **팩트**: 규칙이 확인할 수 있는 정보
    - **액션**: 수행하려는 동작
    - **조건**: 액션을 언제 발생시킬지 지정
    - **규칙**: 실행하려는 비즈니스 규칙을 지정 (보통 팩트, 액션, 조건을 한 그룹으로 묶어서 규칙으로 만든다.)
- 비즈니스 규칙엔진의 생산성과 관련된 좋은점:
    - **규칙이 기존 응용프로그램과는 독립된 곳에서 실행, 유지보수, 테스트할 수 있다는 점.**

## 4. TDD

- 요구사항이 아직 확정되지 않은 유동적인 상태이므로, 사용자가 수행할 기본 기능부터 나열해보면
    - 액션 추가 - 액션 실행 - 기본 보고
- 철학: 테스트 코드를 먼저 만든 후, 이에 맞춰 코드를 구현하는 것. 즉, 실제 코드를 구현하기 전에 테스트 코드를 먼저 구현한다.
- 오버엔지니어링 방지: 테스트를 통과하기 위한 코드를 구현하므로, 필요하지 않은 테스트를 구현하는 일을 줄인다.
- TDD 주기에 따라 요구사항 구현을 반복하면서 종합적인 테스트 스위트(Test suite)를 완성할 수 있으므로 요구사항을 만족시켰다는 사실을 조금 더 확신할 수 있고, 버그발생 범위를 줄일 수 있다.
- 코드를 올바르게 조직할 수 있다. (예: 먼저 테스트를 구현하면서 코드에 어떤 공개 인터페이스를 만들지 신중히 검토할 수 있다.)
- 테스트를 따로 구현하므로 테스트에 대응하는 요구사항을 한개씩 구현할 때마다 필요한 요구사항에 집중하고 개선할 수 있다.

## 5. Mocking (모킹)

Java의 Mockito라이브러리를 이용한다.

1. 목(mock) 생성
2. 메서드가 호출되었는지 확인

```java
mock(): 필요한 목객체를 만들고, 특정 동작이 실행되었는지 확인한다.
verify(): 특정 메서드가 호출되었는지 확인하는 어셔션을 만든다.
```

## 6. 조건 추가하기
- enum + switch를 사용하면 자바 컴파일러가 모든 enum값을 switch에서 소모했는지 확인한다.

## 7. Fluent API
- 플루언트 API: 특정 문제를 더 직관적으로 해결할 수 있도록 특정 도메인에 맞춰진 API를 가리킨다.
- 메서드 체이닝: 더 복잡한 연산도 지정할 수 있다.
- 도메인 모델링
  - 조건(given): 어떤 팩트에 적용할 조건 (참/거짓으로 평가)
  - 액션(when): 실행할 연산이나 코드 집합
  - 규칙(then): 조건과 액션을 합친것 (조건이 참일 경우에만 액션 실행)

## 정리
-  `UnsupportedOperationException()`: 요청한 작업을 지원하지 않는다는 의미를 가진 예외